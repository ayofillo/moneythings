#!groovy

properties([gitLabConnection('GitLab')])

parameters {
    choice(choices: 'https://www.delta.com', description: 'Base URL For Test Environment', name: 'myTestEnvironment');
    string(defaultValue: '', description: 'Spec Path For Test cases', name: 'mySpecPath');
};

/* 	Declarative Pipeline presents a more simplified and opinionated syntax on top of the Pipeline sub-systems.
	All valid Declarative Pipelines must be enclosed within a "pipeline" block.
*/
node {
    timeout(time: 10, unit: 'MINUTES') {
        wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'xterm']) {

            stage('Checkout') {
                scmVars = checkout scm
            };

            /*
                At a minimum it is recommended that "stages" contain at least one "stage" directive for
                each discrete part of the continuous delivery process, such as Build, Test, and Deploy.
                We start our pipeline with dependency check. Dependency-Check is a utility that identifies
                project dependencies and checks if there are any known, publicly disclosed,
                vulnerabilities. Dependency-check automatically updates itself using the NVD Data Feeds
                hosted by NIST.
            */
            sh 'chmod +x mvnw'
            stage('Dependency Check') {

                /*
                    The "steps" section defines a series of one or more steps to be executed in a given
                    stage directive.
                */
                echo 'Initiating clean...'
                /*
                        The "sh" dsl command can be used to run shell commands. In a windows based
                        system we can use "bat" instead. We use "dependencyCheckAnalyze" gradle task to check
                         dependencies
                    */
                sh './mvnw clean'

                /*
                    Dependency-Check is the core engine that includes the evidence-based
                    identification, analysis, and reporting of library information and
                    associated vulnerabilities. Dependency-Check includes a command line
                    interface (CLI), an Ant task, and Maven plugin. All three generate the
                    same HTML and XML reports. The Dependency-Check Jenkins Plugin relies on
                    the XML report generated from the CLI, Ant task or Maven plugin.
                */
            }

            /*
                Next stage we would like to run is to assemble/compile the application.
            */
            stage('Build') {
                echo 'Initiating build...'
                /*
                    The "assemble" task for gradle does this for us. the clean task clears out
                    any previous build artifacts from the workspace.
                */
                sh './mvnw compile'
            }

            /*
                For the next stage we would like to run all the unit tests run for the application.
              */
            stage('Test') {
                echo 'Initiating test...'
                /*
                    The "test" task for gradle invokes the unit tests and generates a test
                    report.
                */
                sh './mvnw test'

                /*
                    The "JUnit" plugin provides a publisher that consumes XML test reports
                    generated by the test task and provides some graphical visualization of
                    the historical test results as well as a web UI for viewing test reports,
                    tracking failures, and so on. Jenkins understands the JUnit test report
                    XML format. This helps Jenkins provide useful information about test
                    results, such as trends.
                */
                junit allowEmptyResults: true, testResults: 'build/test-results/*.xml'
            }
        }
    }
}