#!groovy

properties([gitLabConnection('GitLab')])

parameters {
    choice(choices: 'https://www.delta.com', description: 'Base URL For Test Environment', name: 'myTestEnvironment');
    string(defaultValue: '', description: 'Spec Path For Test cases', name: 'mySpecPath');
};

/* 	Declarative Pipeline presents a more simplified and opinionated syntax on top of the Pipeline sub-systems.
	All valid Declarative Pipelines must be enclosed within a "pipeline" block.
*/
node {
    timeout(time: 330, unit: 'MINUTES') {
        wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'xterm']) {

            stage('Checkout') {
                scmVars = checkout scm
            };

            /*
                At a minimum it is recommended that "stages" contain at least one "stage" directive for
                each discrete part of the continuous delivery process, such as Build, Test, and Deploy.
                We start our pipeline with dependency check. Dependency-Check is a utility that identifies
                project dependencies and checks if there are any known, publicly disclosed,
                vulnerabilities. Dependency-check automatically updates itself using the NVD Data Feeds
                hosted by NIST.
            */
            sh 'pwd'
            sh 'ls -ltra'
            sh 'chmod +x mvnw'
            stage('Dependency Check') {

                /*
                    The "steps" section defines a series of one or more steps to be executed in a given
                    stage directive.
                */
                echo 'Initiating clean...'
                /*
                        The "sh" dsl command can be used to run shell commands. In a windows based
                        system we can use "bat" instead. We use "dependencyCheckAnalyze" gradle task to check
                         dependencies
                    */
                sh './mvnw clean'

                /*
                    Dependency-Check is the core engine that includes the evidence-based
                    identification, analysis, and reporting of library information and
                    associated vulnerabilities. Dependency-Check includes a command line
                    interface (CLI), an Ant task, and Maven plugin. All three generate the
                    same HTML and XML reports. The Dependency-Check Jenkins Plugin relies on
                    the XML report generated from the CLI, Ant task or Maven plugin.
                */
            }

            /*
                Next stage we would like to run is to assemble/compile the application.
            */
            stage('Build') {
                echo 'Initiating build...'
                /*
                    The "assemble" task for gradle does this for us. the clean task clears out
                    any previous build artifacts from the workspace.
                */
                sh './mvnw compile'
            }

            /*
                For the next stage we would like to run all the unit tests run for the application.
              */
            stage('Test') {
                echo 'Initiating test...'
                /*
                    The "test" task for gradle invokes the unit tests and generates a test
                    report.
                */
                sh './mvnw test'

                /*
                    The "JUnit" plugin provides a publisher that consumes XML test reports
                    generated by the test task and provides some graphical visualization of
                    the historical test results as well as a web UI for viewing test reports,
                    tracking failures, and so on. Jenkins understands the JUnit test report
                    XML format. This helps Jenkins provide useful information about test
                    results, such as trends.
                */
                junit allowEmptyResults: true, testResults: 'build/test-results/*.xml'
            }

            /*
                Test code coverage gaurantees that certain percentage of the code has been covered by unit
                tests, no more.	It does not gaurantee the quality of these tests. There could be a bunch
                of test lacking assertions, others missing branchs of logic, all while Test Coverage is
                100%. Mutation testing evaluates the quality of existing software tests. It is a practice
                of  mutating (changing) certain statements in the source code and checking if the test
                cases still pass. The changes in mutant program are kept extremely small, so it does not
                affect the overall objective of the program. The goal  is to for the the test cases to
                fail once mutated, and prove they are robust. This method is also called as Fault based
                testing strategy as it involves creating fault in the program
            */
            stage('Mutation Test') {
                echo 'Initiating pit test...'
                /*
                    The "pitest" plugin provides an ability to perform a mutation testing and
                    calculate a mutation coverage of a Gradle-based projects with PIT.
                */
                sh './mvnw org.pitest:pitest-maven:mutationCoverage'

                /*
                    "HtmlPublisher" plugin is useful to publish the html reports that your build
                    generates to the job and build pages.
                */
                publishHTML([
                        allowMissing         : false,
                        alwaysLinkToLastBuild: false,
                        keepAll              : false,
                        reportDir            : 'build/reports/pitest/',
                        reportFiles          : 'index.html',
                        reportName           : 'Hello Mutation Test Report',
                        reportTitles         : 'Hello Mutation Test Report'
                ])
            }

            /*
                The next stage in pipeline deals with publishing a report documenting the code coverage
                found on this application based on unit tests run.
            */
            stage('Coverage') {
                echo 'code coverage jacoco...'
                /*
                    The "JaCoCo" plugin provides code coverage metrics for Java code via
                    integration with JaCoCo. If the Java plugin is also applied to your
                    project, a new task named "jacocoTestReport" is created that depends on the
                    test task. The report is available at $buildDir/reports/jacoco/test.
                */
                sh './mvnw jacoco:report'

                /*
                    The Jenkins "jacoco" plugin provides two things, a build-publisher to record
                    and display coverage data as part of builds as well as a new column-type for
                    dashboard views which can display coverage data in Dashboards.
                */
//                jacoco execPattern: '**/jacoco.exec'
            }

//            /*
//                Call dependent project
//            */
//            stage('Regression') {
//                echo 'Initiating regression pipeline...'
//                build job: 'poc2'
//            }
        }
    }
}